// Code generated by goa v3.13.2, DO NOT EDIT.
//
// DSLEditor HTTP client CLI support package
//
// Command:
// $ goa gen goa.design/model/mdlsvc/design -o mdlsvc/

package client

import (
	"encoding/json"
	"fmt"

	goa "goa.design/goa/v3/pkg"
	dsleditor "goa.design/model/mdlsvc/gen/dsl_editor"
)

// BuildUpsertSystemPayload builds the payload for the DSLEditor UpsertSystem
// endpoint from CLI flags.
func BuildUpsertSystemPayload(dSLEditorUpsertSystemBody string, dSLEditorUpsertSystemPackagePath string) (*dsleditor.System, error) {
	var err error
	var body UpsertSystemRequestBody
	{
		err = json.Unmarshal([]byte(dSLEditorUpsertSystemBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"Description\": \"System description\",\n      \"Location\": \"External\",\n      \"Name\": \"System\",\n      \"Properties\": {\n         \"key1\": \"value1\",\n         \"key2\": \"value2\"\n      },\n      \"Tags\": [\n         \"Tag1\",\n         \"Tag2\"\n      ],\n      \"URL\": \"https://system.com\"\n   }'")
		}
		if !(body.Location == "Internal" || body.Location == "External") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.Location", body.Location, []any{"Internal", "External"}))
		}
		if err != nil {
			return nil, err
		}
	}
	var packagePath string
	{
		packagePath = dSLEditorUpsertSystemPackagePath
		err = goa.MergeErrors(err, goa.ValidatePattern("PackagePath", packagePath, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &dsleditor.System{
		Name:        body.Name,
		Description: body.Description,
		URL:         body.URL,
		Location:    body.Location,
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	{
		var zero string
		if v.Location == zero {
			v.Location = "Internal"
		}
	}
	if body.Properties != nil {
		v.Properties = make(map[string]string, len(body.Properties))
		for key, val := range body.Properties {
			tk := key
			tv := val
			v.Properties[tk] = tv
		}
	}
	v.PackagePath = packagePath

	return v, nil
}

// BuildUpsertPersonPayload builds the payload for the DSLEditor UpsertPerson
// endpoint from CLI flags.
func BuildUpsertPersonPayload(dSLEditorUpsertPersonBody string, dSLEditorUpsertPersonPackagePath string) (*dsleditor.Person, error) {
	var err error
	var body UpsertPersonRequestBody
	{
		err = json.Unmarshal([]byte(dSLEditorUpsertPersonBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"Description\": \"Person description\",\n      \"Location\": \"Internal\",\n      \"Name\": \"Person\",\n      \"Properties\": {\n         \"key1\": \"value1\",\n         \"key2\": \"value2\"\n      },\n      \"Tags\": [\n         \"Tag1\",\n         \"Tag2\"\n      ],\n      \"URL\": \"https://person.com\"\n   }'")
		}
		if !(body.Location == "Internal" || body.Location == "External") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.Location", body.Location, []any{"Internal", "External"}))
		}
		if err != nil {
			return nil, err
		}
	}
	var packagePath string
	{
		packagePath = dSLEditorUpsertPersonPackagePath
		err = goa.MergeErrors(err, goa.ValidatePattern("PackagePath", packagePath, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &dsleditor.Person{
		Name:        body.Name,
		Description: body.Description,
		URL:         body.URL,
		Location:    body.Location,
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	{
		var zero string
		if v.Location == zero {
			v.Location = "Internal"
		}
	}
	if body.Properties != nil {
		v.Properties = make(map[string]string, len(body.Properties))
		for key, val := range body.Properties {
			tk := key
			tv := val
			v.Properties[tk] = tv
		}
	}
	v.PackagePath = packagePath

	return v, nil
}

// BuildUpsertContainerPayload builds the payload for the DSLEditor
// UpsertContainer endpoint from CLI flags.
func BuildUpsertContainerPayload(dSLEditorUpsertContainerBody string, dSLEditorUpsertContainerPackagePath string) (*dsleditor.Container, error) {
	var err error
	var body UpsertContainerRequestBody
	{
		err = json.Unmarshal([]byte(dSLEditorUpsertContainerBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"Description\": \"Container description\",\n      \"Name\": \"Container\",\n      \"Properties\": {\n         \"key1\": \"value1\",\n         \"key2\": \"value2\"\n      },\n      \"SystemName\": \"My System\",\n      \"Tags\": [\n         \"Tag1\",\n         \"Tag2\"\n      ],\n      \"Technology\": \"Technology\",\n      \"URL\": \"https://container.com\"\n   }'")
		}
	}
	var packagePath string
	{
		packagePath = dSLEditorUpsertContainerPackagePath
		err = goa.MergeErrors(err, goa.ValidatePattern("PackagePath", packagePath, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &dsleditor.Container{
		SystemName:  body.SystemName,
		Name:        body.Name,
		Description: body.Description,
		Technology:  body.Technology,
		URL:         body.URL,
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	if body.Properties != nil {
		v.Properties = make(map[string]string, len(body.Properties))
		for key, val := range body.Properties {
			tk := key
			tv := val
			v.Properties[tk] = tv
		}
	}
	v.PackagePath = packagePath

	return v, nil
}

// BuildUpsertComponentPayload builds the payload for the DSLEditor
// UpsertComponent endpoint from CLI flags.
func BuildUpsertComponentPayload(dSLEditorUpsertComponentBody string, dSLEditorUpsertComponentPackagePath string) (*dsleditor.Component, error) {
	var err error
	var body UpsertComponentRequestBody
	{
		err = json.Unmarshal([]byte(dSLEditorUpsertComponentBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"ContainerName\": \"My Container\",\n      \"Description\": \"Component description\",\n      \"Name\": \"Component\",\n      \"Properties\": {\n         \"key1\": \"value1\",\n         \"key2\": \"value2\"\n      },\n      \"SystemName\": \"My System\",\n      \"Tags\": [\n         \"Tag1\",\n         \"Tag2\"\n      ],\n      \"Technology\": \"Technology\",\n      \"URL\": \"https://component.com\"\n   }'")
		}
	}
	var packagePath string
	{
		packagePath = dSLEditorUpsertComponentPackagePath
		err = goa.MergeErrors(err, goa.ValidatePattern("PackagePath", packagePath, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &dsleditor.Component{
		SystemName:    body.SystemName,
		ContainerName: body.ContainerName,
		Name:          body.Name,
		Description:   body.Description,
		Technology:    body.Technology,
		URL:           body.URL,
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	if body.Properties != nil {
		v.Properties = make(map[string]string, len(body.Properties))
		for key, val := range body.Properties {
			tk := key
			tv := val
			v.Properties[tk] = tv
		}
	}
	v.PackagePath = packagePath

	return v, nil
}

// BuildUpsertRelationshipPayload builds the payload for the DSLEditor
// UpsertRelationship endpoint from CLI flags.
func BuildUpsertRelationshipPayload(dSLEditorUpsertRelationshipBody string, dSLEditorUpsertRelationshipPackagePath string) (*dsleditor.Relationship, error) {
	var err error
	var body UpsertRelationshipRequestBody
	{
		err = json.Unmarshal([]byte(dSLEditorUpsertRelationshipBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"Description\": \"Relationship description\",\n      \"DestinationPath\": \"Software System/Container/Component\",\n      \"InteractionStyle\": \"Asynchronous\",\n      \"SourcePath\": \"Software System/Container/Component\",\n      \"Tags\": [\n         \"Tag1\",\n         \"Tag2\"\n      ],\n      \"Technology\": \"Technology\",\n      \"URL\": \"https://relationship.com\"\n   }'")
		}
		if !(body.InteractionStyle == "Synchronous" || body.InteractionStyle == "Asynchronous") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.InteractionStyle", body.InteractionStyle, []any{"Synchronous", "Asynchronous"}))
		}
		if body.URL != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.URL", *body.URL, goa.FormatURI))
		}
		if err != nil {
			return nil, err
		}
	}
	var packagePath string
	{
		packagePath = dSLEditorUpsertRelationshipPackagePath
		err = goa.MergeErrors(err, goa.ValidatePattern("PackagePath", packagePath, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &dsleditor.Relationship{
		SourcePath:       body.SourcePath,
		DestinationPath:  body.DestinationPath,
		Description:      body.Description,
		Technology:       body.Technology,
		InteractionStyle: body.InteractionStyle,
		URL:              body.URL,
	}
	{
		var zero string
		if v.InteractionStyle == zero {
			v.InteractionStyle = "Synchronous"
		}
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	v.PackagePath = packagePath

	return v, nil
}

// BuildDeleteSystemPayload builds the payload for the DSLEditor DeleteSystem
// endpoint from CLI flags.
func BuildDeleteSystemPayload(dSLEditorDeleteSystemName string, dSLEditorDeleteSystemPackagePath string) (*dsleditor.DeleteSystemPayload, error) {
	var err error
	var name string
	{
		name = dSLEditorDeleteSystemName
	}
	var packagePath string
	{
		packagePath = dSLEditorDeleteSystemPackagePath
		err = goa.MergeErrors(err, goa.ValidatePattern("PackagePath", packagePath, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &dsleditor.DeleteSystemPayload{}
	v.Name = name
	v.PackagePath = packagePath

	return v, nil
}

// BuildDeletePersonPayload builds the payload for the DSLEditor DeletePerson
// endpoint from CLI flags.
func BuildDeletePersonPayload(dSLEditorDeletePersonName string, dSLEditorDeletePersonPackagePath string) (*dsleditor.DeletePersonPayload, error) {
	var err error
	var name string
	{
		name = dSLEditorDeletePersonName
	}
	var packagePath string
	{
		packagePath = dSLEditorDeletePersonPackagePath
		err = goa.MergeErrors(err, goa.ValidatePattern("PackagePath", packagePath, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &dsleditor.DeletePersonPayload{}
	v.Name = name
	v.PackagePath = packagePath

	return v, nil
}

// BuildDeleteContainerPayload builds the payload for the DSLEditor
// DeleteContainer endpoint from CLI flags.
func BuildDeleteContainerPayload(dSLEditorDeleteContainerSystemName string, dSLEditorDeleteContainerName string, dSLEditorDeleteContainerPackagePath string) (*dsleditor.DeleteContainerPayload, error) {
	var err error
	var systemName string
	{
		systemName = dSLEditorDeleteContainerSystemName
	}
	var name string
	{
		name = dSLEditorDeleteContainerName
	}
	var packagePath string
	{
		packagePath = dSLEditorDeleteContainerPackagePath
		err = goa.MergeErrors(err, goa.ValidatePattern("PackagePath", packagePath, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &dsleditor.DeleteContainerPayload{}
	v.SystemName = systemName
	v.Name = name
	v.PackagePath = packagePath

	return v, nil
}

// BuildDeleteComponentPayload builds the payload for the DSLEditor
// DeleteComponent endpoint from CLI flags.
func BuildDeleteComponentPayload(dSLEditorDeleteComponentSystemName string, dSLEditorDeleteComponentContainerName string, dSLEditorDeleteComponentName string, dSLEditorDeleteComponentPackagePath string) (*dsleditor.DeleteComponentPayload, error) {
	var err error
	var systemName string
	{
		systemName = dSLEditorDeleteComponentSystemName
	}
	var containerName string
	{
		containerName = dSLEditorDeleteComponentContainerName
	}
	var name string
	{
		name = dSLEditorDeleteComponentName
	}
	var packagePath string
	{
		packagePath = dSLEditorDeleteComponentPackagePath
		err = goa.MergeErrors(err, goa.ValidatePattern("PackagePath", packagePath, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &dsleditor.DeleteComponentPayload{}
	v.SystemName = systemName
	v.ContainerName = containerName
	v.Name = name
	v.PackagePath = packagePath

	return v, nil
}

// BuildDeleteRelationshipPayload builds the payload for the DSLEditor
// DeleteRelationship endpoint from CLI flags.
func BuildDeleteRelationshipPayload(dSLEditorDeleteRelationshipSourcePath string, dSLEditorDeleteRelationshipDestinationPath string, dSLEditorDeleteRelationshipPackagePath string) (*dsleditor.DeleteRelationshipPayload, error) {
	var err error
	var sourcePath string
	{
		sourcePath = dSLEditorDeleteRelationshipSourcePath
	}
	var destinationPath string
	{
		destinationPath = dSLEditorDeleteRelationshipDestinationPath
	}
	var packagePath string
	{
		packagePath = dSLEditorDeleteRelationshipPackagePath
		err = goa.MergeErrors(err, goa.ValidatePattern("PackagePath", packagePath, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &dsleditor.DeleteRelationshipPayload{}
	v.SourcePath = sourcePath
	v.DestinationPath = destinationPath
	v.PackagePath = packagePath

	return v, nil
}
