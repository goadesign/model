// Code generated by goa v3.13.2, DO NOT EDIT.
//
// DSLEditor HTTP client CLI support package
//
// Command:
// $ goa gen goa.design/model/mdlsvc/design -o mdlsvc/

package client

import (
	"encoding/json"
	"fmt"
	"unicode/utf8"

	goa "goa.design/goa/v3/pkg"
	dsleditor "goa.design/model/mdlsvc/gen/dsl_editor"
	types "goa.design/model/mdlsvc/gen/types"
)

// BuildUpdateDSLPayload builds the payload for the DSLEditor UpdateDSL
// endpoint from CLI flags.
func BuildUpdateDSLPayload(dSLEditorUpdateDSLBody string) (*types.PackageFile, error) {
	var err error
	var body UpdateDSLRequestBody
	{
		err = json.Unmarshal([]byte(dSLEditorUpdateDSLBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"Content\": \"import . \\\"goa.design/model/dsl\\\"\\n\\nvar _ = Design(func() {})\",\n      \"Locator\": {\n         \"Dir\": \"src/repo/model\",\n         \"Filename\": \"model.go\",\n         \"Workspace\": \"my-workspace\"\n      }\n   }'")
		}
		if body.Locator == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("Locator", "body"))
		}
		if body.Locator != nil {
			if err2 := ValidateFileLocatorRequestBody(body.Locator); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("body.Content", body.Content, "import . \"goa.design/model/dsl\""))
		if utf8.RuneCountInString(body.Content) < 58 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.Content", body.Content, utf8.RuneCountInString(body.Content), 58, true))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &types.PackageFile{
		Content: body.Content,
	}
	if body.Locator != nil {
		v.Locator = marshalFileLocatorRequestBodyToTypesFileLocator(body.Locator)
	}

	return v, nil
}

// BuildUpsertSystemPayload builds the payload for the DSLEditor UpsertSystem
// endpoint from CLI flags.
func BuildUpsertSystemPayload(dSLEditorUpsertSystemBody string) (*dsleditor.System, error) {
	var err error
	var body UpsertSystemRequestBody
	{
		err = json.Unmarshal([]byte(dSLEditorUpsertSystemBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"Description\": \"System description\",\n      \"Location\": \"External\",\n      \"Locator\": {\n         \"Dir\": \"src/repo/model\",\n         \"Filename\": \"model.go\",\n         \"Workspace\": \"my-workspace\"\n      },\n      \"Name\": \"System\",\n      \"Properties\": {\n         \"key1\": \"value1\",\n         \"key2\": \"value2\"\n      },\n      \"Tags\": [\n         \"Tag1\",\n         \"Tag2\"\n      ],\n      \"URL\": \"https://system.com\"\n   }'")
		}
		if body.Locator != nil {
			if err2 := ValidateFileLocatorRequestBody(body.Locator); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if !(body.Location == "Internal" || body.Location == "External") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.Location", body.Location, []any{"Internal", "External"}))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &dsleditor.System{
		Name:        body.Name,
		Description: body.Description,
		URL:         body.URL,
		Location:    body.Location,
	}
	if body.Locator != nil {
		v.Locator = marshalFileLocatorRequestBodyToTypesFileLocator(body.Locator)
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	{
		var zero string
		if v.Location == zero {
			v.Location = "Internal"
		}
	}
	if body.Properties != nil {
		v.Properties = make(map[string]string, len(body.Properties))
		for key, val := range body.Properties {
			tk := key
			tv := val
			v.Properties[tk] = tv
		}
	}

	return v, nil
}

// BuildUpsertPersonPayload builds the payload for the DSLEditor UpsertPerson
// endpoint from CLI flags.
func BuildUpsertPersonPayload(dSLEditorUpsertPersonBody string) (*dsleditor.Person, error) {
	var err error
	var body UpsertPersonRequestBody
	{
		err = json.Unmarshal([]byte(dSLEditorUpsertPersonBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"Description\": \"Person description\",\n      \"Location\": \"External\",\n      \"Locator\": {\n         \"Dir\": \"src/repo/model\",\n         \"Filename\": \"model.go\",\n         \"Workspace\": \"my-workspace\"\n      },\n      \"Name\": \"Person\",\n      \"Properties\": {\n         \"key1\": \"value1\",\n         \"key2\": \"value2\"\n      },\n      \"Tags\": [\n         \"Tag1\",\n         \"Tag2\"\n      ],\n      \"URL\": \"https://person.com\"\n   }'")
		}
		if body.Locator != nil {
			if err2 := ValidateFileLocatorRequestBody(body.Locator); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if !(body.Location == "Internal" || body.Location == "External") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.Location", body.Location, []any{"Internal", "External"}))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &dsleditor.Person{
		Name:        body.Name,
		Description: body.Description,
		URL:         body.URL,
		Location:    body.Location,
	}
	if body.Locator != nil {
		v.Locator = marshalFileLocatorRequestBodyToTypesFileLocator(body.Locator)
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	{
		var zero string
		if v.Location == zero {
			v.Location = "Internal"
		}
	}
	if body.Properties != nil {
		v.Properties = make(map[string]string, len(body.Properties))
		for key, val := range body.Properties {
			tk := key
			tv := val
			v.Properties[tk] = tv
		}
	}

	return v, nil
}

// BuildUpsertContainerPayload builds the payload for the DSLEditor
// UpsertContainer endpoint from CLI flags.
func BuildUpsertContainerPayload(dSLEditorUpsertContainerBody string) (*dsleditor.Container, error) {
	var err error
	var body UpsertContainerRequestBody
	{
		err = json.Unmarshal([]byte(dSLEditorUpsertContainerBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"Description\": \"Container description\",\n      \"Locator\": {\n         \"Dir\": \"src/repo/model\",\n         \"Filename\": \"model.go\",\n         \"Workspace\": \"my-workspace\"\n      },\n      \"Name\": \"Container\",\n      \"Properties\": {\n         \"key1\": \"value1\",\n         \"key2\": \"value2\"\n      },\n      \"SystemName\": \"My System\",\n      \"Tags\": [\n         \"Tag1\",\n         \"Tag2\"\n      ],\n      \"Technology\": \"Technology\",\n      \"URL\": \"https://container.com\"\n   }'")
		}
		if body.Locator != nil {
			if err2 := ValidateFileLocatorRequestBody(body.Locator); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if err != nil {
			return nil, err
		}
	}
	v := &dsleditor.Container{
		SystemName:  body.SystemName,
		Name:        body.Name,
		Description: body.Description,
		Technology:  body.Technology,
		URL:         body.URL,
	}
	if body.Locator != nil {
		v.Locator = marshalFileLocatorRequestBodyToTypesFileLocator(body.Locator)
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	if body.Properties != nil {
		v.Properties = make(map[string]string, len(body.Properties))
		for key, val := range body.Properties {
			tk := key
			tv := val
			v.Properties[tk] = tv
		}
	}

	return v, nil
}

// BuildUpsertComponentPayload builds the payload for the DSLEditor
// UpsertComponent endpoint from CLI flags.
func BuildUpsertComponentPayload(dSLEditorUpsertComponentBody string) (*dsleditor.Component, error) {
	var err error
	var body UpsertComponentRequestBody
	{
		err = json.Unmarshal([]byte(dSLEditorUpsertComponentBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"ContainerName\": \"My Container\",\n      \"Description\": \"Component description\",\n      \"Locator\": {\n         \"Dir\": \"src/repo/model\",\n         \"Filename\": \"model.go\",\n         \"Workspace\": \"my-workspace\"\n      },\n      \"Name\": \"Component\",\n      \"Properties\": {\n         \"key1\": \"value1\",\n         \"key2\": \"value2\"\n      },\n      \"SystemName\": \"My System\",\n      \"Tags\": [\n         \"Tag1\",\n         \"Tag2\"\n      ],\n      \"Technology\": \"Technology\",\n      \"URL\": \"https://component.com\"\n   }'")
		}
		if body.Locator != nil {
			if err2 := ValidateFileLocatorRequestBody(body.Locator); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if err != nil {
			return nil, err
		}
	}
	v := &dsleditor.Component{
		SystemName:    body.SystemName,
		ContainerName: body.ContainerName,
		Name:          body.Name,
		Description:   body.Description,
		Technology:    body.Technology,
		URL:           body.URL,
	}
	if body.Locator != nil {
		v.Locator = marshalFileLocatorRequestBodyToTypesFileLocator(body.Locator)
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	if body.Properties != nil {
		v.Properties = make(map[string]string, len(body.Properties))
		for key, val := range body.Properties {
			tk := key
			tv := val
			v.Properties[tk] = tv
		}
	}

	return v, nil
}

// BuildUpsertRelationshipPayload builds the payload for the DSLEditor
// UpsertRelationship endpoint from CLI flags.
func BuildUpsertRelationshipPayload(dSLEditorUpsertRelationshipBody string) (*dsleditor.Relationship, error) {
	var err error
	var body UpsertRelationshipRequestBody
	{
		err = json.Unmarshal([]byte(dSLEditorUpsertRelationshipBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"Description\": \"Relationship description\",\n      \"DestinationPath\": \"Software System/Container/Component\",\n      \"InteractionStyle\": \"Synchronous\",\n      \"Locator\": {\n         \"Dir\": \"src/repo/model\",\n         \"Filename\": \"model.go\",\n         \"Workspace\": \"my-workspace\"\n      },\n      \"SourcePath\": \"Software System/Container/Component\",\n      \"Tags\": [\n         \"Tag1\",\n         \"Tag2\"\n      ],\n      \"Technology\": \"Technology\",\n      \"URL\": \"https://relationship.com\"\n   }'")
		}
		if body.Locator != nil {
			if err2 := ValidateFileLocatorRequestBody(body.Locator); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if !(body.InteractionStyle == "Synchronous" || body.InteractionStyle == "Asynchronous") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.InteractionStyle", body.InteractionStyle, []any{"Synchronous", "Asynchronous"}))
		}
		if body.URL != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.URL", *body.URL, goa.FormatURI))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &dsleditor.Relationship{
		SourcePath:       body.SourcePath,
		DestinationPath:  body.DestinationPath,
		Description:      body.Description,
		Technology:       body.Technology,
		InteractionStyle: body.InteractionStyle,
		URL:              body.URL,
	}
	if body.Locator != nil {
		v.Locator = marshalFileLocatorRequestBodyToTypesFileLocator(body.Locator)
	}
	{
		var zero string
		if v.InteractionStyle == zero {
			v.InteractionStyle = "Synchronous"
		}
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}

	return v, nil
}

// BuildDeleteSystemPayload builds the payload for the DSLEditor DeleteSystem
// endpoint from CLI flags.
func BuildDeleteSystemPayload(dSLEditorDeleteSystemBody string, dSLEditorDeleteSystemSystemName string) (*dsleditor.DeleteSystemPayload, error) {
	var err error
	var body DeleteSystemRequestBody
	{
		err = json.Unmarshal([]byte(dSLEditorDeleteSystemBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"Dir\": \"src/repo/model\",\n      \"Filename\": \"model.go\",\n      \"Workspace\": \"my-workspace\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("body.Filename", body.Filename, "\\.go$"))
		if utf8.RuneCountInString(body.Workspace) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.Workspace", body.Workspace, utf8.RuneCountInString(body.Workspace), 1, true))
		}
		if utf8.RuneCountInString(body.Dir) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.Dir", body.Dir, utf8.RuneCountInString(body.Dir), 1, true))
		}
		if err != nil {
			return nil, err
		}
	}
	var systemName string
	{
		systemName = dSLEditorDeleteSystemSystemName
	}
	v := &dsleditor.DeleteSystemPayload{
		Filename:  body.Filename,
		Workspace: body.Workspace,
		Dir:       body.Dir,
	}
	v.SystemName = systemName

	return v, nil
}

// BuildDeletePersonPayload builds the payload for the DSLEditor DeletePerson
// endpoint from CLI flags.
func BuildDeletePersonPayload(dSLEditorDeletePersonBody string, dSLEditorDeletePersonPersonName string) (*dsleditor.DeletePersonPayload, error) {
	var err error
	var body DeletePersonRequestBody
	{
		err = json.Unmarshal([]byte(dSLEditorDeletePersonBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"Dir\": \"src/repo/model\",\n      \"Filename\": \"model.go\",\n      \"Workspace\": \"my-workspace\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("body.Filename", body.Filename, "\\.go$"))
		if utf8.RuneCountInString(body.Workspace) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.Workspace", body.Workspace, utf8.RuneCountInString(body.Workspace), 1, true))
		}
		if utf8.RuneCountInString(body.Dir) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.Dir", body.Dir, utf8.RuneCountInString(body.Dir), 1, true))
		}
		if err != nil {
			return nil, err
		}
	}
	var personName string
	{
		personName = dSLEditorDeletePersonPersonName
	}
	v := &dsleditor.DeletePersonPayload{
		Filename:  body.Filename,
		Workspace: body.Workspace,
		Dir:       body.Dir,
	}
	v.PersonName = personName

	return v, nil
}

// BuildDeleteContainerPayload builds the payload for the DSLEditor
// DeleteContainer endpoint from CLI flags.
func BuildDeleteContainerPayload(dSLEditorDeleteContainerBody string, dSLEditorDeleteContainerSystemName string, dSLEditorDeleteContainerContainerName string) (*dsleditor.DeleteContainerPayload, error) {
	var err error
	var body DeleteContainerRequestBody
	{
		err = json.Unmarshal([]byte(dSLEditorDeleteContainerBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"Dir\": \"src/repo/model\",\n      \"Filename\": \"model.go\",\n      \"Workspace\": \"my-workspace\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("body.Filename", body.Filename, "\\.go$"))
		if utf8.RuneCountInString(body.Workspace) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.Workspace", body.Workspace, utf8.RuneCountInString(body.Workspace), 1, true))
		}
		if utf8.RuneCountInString(body.Dir) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.Dir", body.Dir, utf8.RuneCountInString(body.Dir), 1, true))
		}
		if err != nil {
			return nil, err
		}
	}
	var systemName string
	{
		systemName = dSLEditorDeleteContainerSystemName
	}
	var containerName string
	{
		containerName = dSLEditorDeleteContainerContainerName
	}
	v := &dsleditor.DeleteContainerPayload{
		Filename:  body.Filename,
		Workspace: body.Workspace,
		Dir:       body.Dir,
	}
	v.SystemName = &systemName
	v.ContainerName = containerName

	return v, nil
}

// BuildDeleteComponentPayload builds the payload for the DSLEditor
// DeleteComponent endpoint from CLI flags.
func BuildDeleteComponentPayload(dSLEditorDeleteComponentBody string, dSLEditorDeleteComponentSystemName string, dSLEditorDeleteComponentContainerName string, dSLEditorDeleteComponentComponentName string) (*dsleditor.DeleteComponentPayload, error) {
	var err error
	var body DeleteComponentRequestBody
	{
		err = json.Unmarshal([]byte(dSLEditorDeleteComponentBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"Dir\": \"src/repo/model\",\n      \"Filename\": \"model.go\",\n      \"Workspace\": \"my-workspace\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("body.Filename", body.Filename, "\\.go$"))
		if utf8.RuneCountInString(body.Workspace) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.Workspace", body.Workspace, utf8.RuneCountInString(body.Workspace), 1, true))
		}
		if utf8.RuneCountInString(body.Dir) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.Dir", body.Dir, utf8.RuneCountInString(body.Dir), 1, true))
		}
		if err != nil {
			return nil, err
		}
	}
	var systemName string
	{
		systemName = dSLEditorDeleteComponentSystemName
	}
	var containerName string
	{
		containerName = dSLEditorDeleteComponentContainerName
	}
	var componentName string
	{
		componentName = dSLEditorDeleteComponentComponentName
	}
	v := &dsleditor.DeleteComponentPayload{
		Filename:  body.Filename,
		Workspace: body.Workspace,
		Dir:       body.Dir,
	}
	v.SystemName = systemName
	v.ContainerName = containerName
	v.ComponentName = componentName

	return v, nil
}

// BuildDeleteRelationshipPayload builds the payload for the DSLEditor
// DeleteRelationship endpoint from CLI flags.
func BuildDeleteRelationshipPayload(dSLEditorDeleteRelationshipBody string) (*dsleditor.DeleteRelationshipPayload, error) {
	var err error
	var body DeleteRelationshipRequestBody
	{
		err = json.Unmarshal([]byte(dSLEditorDeleteRelationshipBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"DestinationPath\": \"Software System/Container/Component\",\n      \"Dir\": \"src/repo/model\",\n      \"Filename\": \"model.go\",\n      \"SourcePath\": \"Software System/Container/Component\",\n      \"Workspace\": \"my-workspace\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("body.Filename", body.Filename, "\\.go$"))
		if utf8.RuneCountInString(body.Workspace) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.Workspace", body.Workspace, utf8.RuneCountInString(body.Workspace), 1, true))
		}
		if utf8.RuneCountInString(body.Dir) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.Dir", body.Dir, utf8.RuneCountInString(body.Dir), 1, true))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &dsleditor.DeleteRelationshipPayload{
		SourcePath:      body.SourcePath,
		DestinationPath: body.DestinationPath,
		Filename:        body.Filename,
		Workspace:       body.Workspace,
		Dir:             body.Dir,
	}

	return v, nil
}
