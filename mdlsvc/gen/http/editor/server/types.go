// Code generated by goa v3.13.2, DO NOT EDIT.
//
// Editor HTTP server types
//
// Command:
// $ goa gen goa.design/model/mdlsvc/design -o mdlsvc/

package server

import (
	goa "goa.design/goa/v3/pkg"
	editor "goa.design/model/mdlsvc/gen/editor"
)

// UpsertSystemRequestBody is the type of the "Editor" service "UpsertSystem"
// endpoint HTTP request body.
type UpsertSystemRequestBody struct {
	// Name of software system
	Name *string `form:"Name,omitempty" json:"Name,omitempty" xml:"Name,omitempty"`
	// Description of system
	Description *string `form:"Description,omitempty" json:"Description,omitempty" xml:"Description,omitempty"`
	// Attached tags
	Tags []string `form:"Tags,omitempty" json:"Tags,omitempty" xml:"Tags,omitempty"`
	// Documentation URL
	URL *string `form:"URL,omitempty" json:"URL,omitempty" xml:"URL,omitempty"`
	// Indicates whether the system is in-house (Internal) or hosted by a third
	// party (External)
	Location *string `form:"Location,omitempty" json:"Location,omitempty" xml:"Location,omitempty"`
	// Set of arbitrary name-value properties (shown in diagram tooltips)
	Properties map[string]string `form:"Properties,omitempty" json:"Properties,omitempty" xml:"Properties,omitempty"`
}

// UpsertPersonRequestBody is the type of the "Editor" service "UpsertPerson"
// endpoint HTTP request body.
type UpsertPersonRequestBody struct {
	// Name of person
	Name *string `form:"Name,omitempty" json:"Name,omitempty" xml:"Name,omitempty"`
	// Description of person
	Description *string `form:"Description,omitempty" json:"Description,omitempty" xml:"Description,omitempty"`
	// Attached tags
	Tags []string `form:"Tags,omitempty" json:"Tags,omitempty" xml:"Tags,omitempty"`
	// Documentation URL
	URL *string `form:"URL,omitempty" json:"URL,omitempty" xml:"URL,omitempty"`
	// Indicates whether the person is an employee (Internal) or a third party
	// (External)
	Location *string `form:"Location,omitempty" json:"Location,omitempty" xml:"Location,omitempty"`
	// Set of arbitrary name-value properties (shown in diagram tooltips)
	Properties map[string]string `form:"Properties,omitempty" json:"Properties,omitempty" xml:"Properties,omitempty"`
}

// UpsertContainerRequestBody is the type of the "Editor" service
// "UpsertContainer" endpoint HTTP request body.
type UpsertContainerRequestBody struct {
	// Name of parent software system
	SystemName *string `form:"SystemName,omitempty" json:"SystemName,omitempty" xml:"SystemName,omitempty"`
	// Name of container
	Name *string `form:"Name,omitempty" json:"Name,omitempty" xml:"Name,omitempty"`
	// Description of container
	Description *string `form:"Description,omitempty" json:"Description,omitempty" xml:"Description,omitempty"`
	// Technology used by container
	Technology *string `form:"Technology,omitempty" json:"Technology,omitempty" xml:"Technology,omitempty"`
	// Attached tags
	Tags []string `form:"Tags,omitempty" json:"Tags,omitempty" xml:"Tags,omitempty"`
	// Documentation URL
	URL *string `form:"URL,omitempty" json:"URL,omitempty" xml:"URL,omitempty"`
	// Set of arbitrary name-value properties (shown in diagram tooltips)
	Properties map[string]string `form:"Properties,omitempty" json:"Properties,omitempty" xml:"Properties,omitempty"`
}

// UpsertComponentRequestBody is the type of the "Editor" service
// "UpsertComponent" endpoint HTTP request body.
type UpsertComponentRequestBody struct {
	// Name of parent software system
	SystemName *string `form:"SystemName,omitempty" json:"SystemName,omitempty" xml:"SystemName,omitempty"`
	// Name of parent container
	ContainerName *string `form:"ContainerName,omitempty" json:"ContainerName,omitempty" xml:"ContainerName,omitempty"`
	// Name of component
	Name *string `form:"Name,omitempty" json:"Name,omitempty" xml:"Name,omitempty"`
	// Description of component
	Description *string `form:"Description,omitempty" json:"Description,omitempty" xml:"Description,omitempty"`
	// Technology used by component
	Technology *string `form:"Technology,omitempty" json:"Technology,omitempty" xml:"Technology,omitempty"`
	// Attached tags
	Tags []string `form:"Tags,omitempty" json:"Tags,omitempty" xml:"Tags,omitempty"`
	// Documentation URL
	URL *string `form:"URL,omitempty" json:"URL,omitempty" xml:"URL,omitempty"`
	// Set of arbitrary name-value properties (shown in diagram tooltips)
	Properties map[string]string `form:"Properties,omitempty" json:"Properties,omitempty" xml:"Properties,omitempty"`
}

// UpsertRelationshipRequestBody is the type of the "Editor" service
// "UpsertRelationship" endpoint HTTP request body.
type UpsertRelationshipRequestBody struct {
	// Path to source element consisting of <software system name>[/<container
	// name>[/<component name>]]
	SourcePath *string `form:"SourcePath,omitempty" json:"SourcePath,omitempty" xml:"SourcePath,omitempty"`
	// Path to destination element, see SourcePath for details.
	DestinationPath *string `form:"DestinationPath,omitempty" json:"DestinationPath,omitempty" xml:"DestinationPath,omitempty"`
	// Description of relationship
	Description *string `form:"Description,omitempty" json:"Description,omitempty" xml:"Description,omitempty"`
	// Technology used by relationship
	Technology *string `form:"Technology,omitempty" json:"Technology,omitempty" xml:"Technology,omitempty"`
	// Indicates whether the relationship is synchronous or asynchronous
	InteractionStyle *string `form:"InteractionStyle,omitempty" json:"InteractionStyle,omitempty" xml:"InteractionStyle,omitempty"`
	// Attached tags
	Tags []string `form:"Tags,omitempty" json:"Tags,omitempty" xml:"Tags,omitempty"`
	// Documentation URL
	URL *string `form:"URL,omitempty" json:"URL,omitempty" xml:"URL,omitempty"`
}

// DeleteSystemNotFoundResponseBody is the type of the "Editor" service
// "DeleteSystem" endpoint HTTP response body for the "NotFound" error.
type DeleteSystemNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// DeletePersonNotFoundResponseBody is the type of the "Editor" service
// "DeletePerson" endpoint HTTP response body for the "NotFound" error.
type DeletePersonNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// DeleteContainerNotFoundResponseBody is the type of the "Editor" service
// "DeleteContainer" endpoint HTTP response body for the "NotFound" error.
type DeleteContainerNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// DeleteComponentNotFoundResponseBody is the type of the "Editor" service
// "DeleteComponent" endpoint HTTP response body for the "NotFound" error.
type DeleteComponentNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// DeleteRelationshipNotFoundResponseBody is the type of the "Editor" service
// "DeleteRelationship" endpoint HTTP response body for the "NotFound" error.
type DeleteRelationshipNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// NewDeleteSystemNotFoundResponseBody builds the HTTP response body from the
// result of the "DeleteSystem" endpoint of the "Editor" service.
func NewDeleteSystemNotFoundResponseBody(res *goa.ServiceError) *DeleteSystemNotFoundResponseBody {
	body := &DeleteSystemNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewDeletePersonNotFoundResponseBody builds the HTTP response body from the
// result of the "DeletePerson" endpoint of the "Editor" service.
func NewDeletePersonNotFoundResponseBody(res *goa.ServiceError) *DeletePersonNotFoundResponseBody {
	body := &DeletePersonNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewDeleteContainerNotFoundResponseBody builds the HTTP response body from
// the result of the "DeleteContainer" endpoint of the "Editor" service.
func NewDeleteContainerNotFoundResponseBody(res *goa.ServiceError) *DeleteContainerNotFoundResponseBody {
	body := &DeleteContainerNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewDeleteComponentNotFoundResponseBody builds the HTTP response body from
// the result of the "DeleteComponent" endpoint of the "Editor" service.
func NewDeleteComponentNotFoundResponseBody(res *goa.ServiceError) *DeleteComponentNotFoundResponseBody {
	body := &DeleteComponentNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewDeleteRelationshipNotFoundResponseBody builds the HTTP response body from
// the result of the "DeleteRelationship" endpoint of the "Editor" service.
func NewDeleteRelationshipNotFoundResponseBody(res *goa.ServiceError) *DeleteRelationshipNotFoundResponseBody {
	body := &DeleteRelationshipNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewUpsertSystemSystem builds a Editor service UpsertSystem endpoint payload.
func NewUpsertSystemSystem(body *UpsertSystemRequestBody, goMod string) *editor.System {
	v := &editor.System{
		Name:        *body.Name,
		Description: body.Description,
		URL:         body.URL,
	}
	if body.Location != nil {
		v.Location = *body.Location
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	if body.Location == nil {
		v.Location = "Internal"
	}
	if body.Properties != nil {
		v.Properties = make(map[string]string, len(body.Properties))
		for key, val := range body.Properties {
			tk := key
			tv := val
			v.Properties[tk] = tv
		}
	}
	v.GoMod = goMod

	return v
}

// NewUpsertPersonPerson builds a Editor service UpsertPerson endpoint payload.
func NewUpsertPersonPerson(body *UpsertPersonRequestBody, goMod string) *editor.Person {
	v := &editor.Person{
		Name:        *body.Name,
		Description: body.Description,
		URL:         body.URL,
	}
	if body.Location != nil {
		v.Location = *body.Location
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	if body.Location == nil {
		v.Location = "Internal"
	}
	if body.Properties != nil {
		v.Properties = make(map[string]string, len(body.Properties))
		for key, val := range body.Properties {
			tk := key
			tv := val
			v.Properties[tk] = tv
		}
	}
	v.GoMod = goMod

	return v
}

// NewUpsertContainerContainer builds a Editor service UpsertContainer endpoint
// payload.
func NewUpsertContainerContainer(body *UpsertContainerRequestBody, goMod string) *editor.Container {
	v := &editor.Container{
		SystemName:  *body.SystemName,
		Name:        *body.Name,
		Description: body.Description,
		Technology:  body.Technology,
		URL:         body.URL,
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	if body.Properties != nil {
		v.Properties = make(map[string]string, len(body.Properties))
		for key, val := range body.Properties {
			tk := key
			tv := val
			v.Properties[tk] = tv
		}
	}
	v.GoMod = goMod

	return v
}

// NewUpsertComponentComponent builds a Editor service UpsertComponent endpoint
// payload.
func NewUpsertComponentComponent(body *UpsertComponentRequestBody, goMod string) *editor.Component {
	v := &editor.Component{
		SystemName:    *body.SystemName,
		ContainerName: *body.ContainerName,
		Name:          *body.Name,
		Description:   body.Description,
		Technology:    body.Technology,
		URL:           body.URL,
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	if body.Properties != nil {
		v.Properties = make(map[string]string, len(body.Properties))
		for key, val := range body.Properties {
			tk := key
			tv := val
			v.Properties[tk] = tv
		}
	}
	v.GoMod = goMod

	return v
}

// NewUpsertRelationshipRelationship builds a Editor service UpsertRelationship
// endpoint payload.
func NewUpsertRelationshipRelationship(body *UpsertRelationshipRequestBody, goMod string) *editor.Relationship {
	v := &editor.Relationship{
		SourcePath:      *body.SourcePath,
		DestinationPath: *body.DestinationPath,
		Description:     body.Description,
		Technology:      body.Technology,
		URL:             body.URL,
	}
	if body.InteractionStyle != nil {
		v.InteractionStyle = *body.InteractionStyle
	}
	if body.InteractionStyle == nil {
		v.InteractionStyle = "Synchronous"
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	v.GoMod = goMod

	return v
}

// NewDeleteSystemPayload builds a Editor service DeleteSystem endpoint payload.
func NewDeleteSystemPayload(name string, goMod string) *editor.DeleteSystemPayload {
	v := &editor.DeleteSystemPayload{}
	v.Name = name
	v.GoMod = goMod

	return v
}

// NewDeletePersonPayload builds a Editor service DeletePerson endpoint payload.
func NewDeletePersonPayload(name string, goMod string) *editor.DeletePersonPayload {
	v := &editor.DeletePersonPayload{}
	v.Name = name
	v.GoMod = goMod

	return v
}

// NewDeleteContainerPayload builds a Editor service DeleteContainer endpoint
// payload.
func NewDeleteContainerPayload(systemName string, name string, goMod string) *editor.DeleteContainerPayload {
	v := &editor.DeleteContainerPayload{}
	v.SystemName = systemName
	v.Name = name
	v.GoMod = goMod

	return v
}

// NewDeleteComponentPayload builds a Editor service DeleteComponent endpoint
// payload.
func NewDeleteComponentPayload(systemName string, containerName string, name string, goMod string) *editor.DeleteComponentPayload {
	v := &editor.DeleteComponentPayload{}
	v.SystemName = systemName
	v.ContainerName = containerName
	v.Name = name
	v.GoMod = goMod

	return v
}

// NewDeleteRelationshipPayload builds a Editor service DeleteRelationship
// endpoint payload.
func NewDeleteRelationshipPayload(sourcePath string, destinationPath string, goMod string) *editor.DeleteRelationshipPayload {
	v := &editor.DeleteRelationshipPayload{}
	v.SourcePath = sourcePath
	v.DestinationPath = destinationPath
	v.GoMod = goMod

	return v
}

// ValidateUpsertSystemRequestBody runs the validations defined on
// UpsertSystemRequestBody
func ValidateUpsertSystemRequestBody(body *UpsertSystemRequestBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("Name", "body"))
	}
	if body.Location != nil {
		if !(*body.Location == "Internal" || *body.Location == "External") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.Location", *body.Location, []any{"Internal", "External"}))
		}
	}
	return
}

// ValidateUpsertPersonRequestBody runs the validations defined on
// UpsertPersonRequestBody
func ValidateUpsertPersonRequestBody(body *UpsertPersonRequestBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("Name", "body"))
	}
	if body.Location != nil {
		if !(*body.Location == "Internal" || *body.Location == "External") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.Location", *body.Location, []any{"Internal", "External"}))
		}
	}
	return
}

// ValidateUpsertContainerRequestBody runs the validations defined on
// UpsertContainerRequestBody
func ValidateUpsertContainerRequestBody(body *UpsertContainerRequestBody) (err error) {
	if body.SystemName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("SystemName", "body"))
	}
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("Name", "body"))
	}
	return
}

// ValidateUpsertComponentRequestBody runs the validations defined on
// UpsertComponentRequestBody
func ValidateUpsertComponentRequestBody(body *UpsertComponentRequestBody) (err error) {
	if body.SystemName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("SystemName", "body"))
	}
	if body.ContainerName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("ContainerName", "body"))
	}
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("Name", "body"))
	}
	return
}

// ValidateUpsertRelationshipRequestBody runs the validations defined on
// UpsertRelationshipRequestBody
func ValidateUpsertRelationshipRequestBody(body *UpsertRelationshipRequestBody) (err error) {
	if body.SourcePath == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("SourcePath", "body"))
	}
	if body.DestinationPath == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("DestinationPath", "body"))
	}
	if body.InteractionStyle != nil {
		if !(*body.InteractionStyle == "Synchronous" || *body.InteractionStyle == "Asynchronous") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.InteractionStyle", *body.InteractionStyle, []any{"Synchronous", "Asynchronous"}))
		}
	}
	if body.URL != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.URL", *body.URL, goa.FormatURI))
	}
	return
}
