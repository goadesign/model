// Code generated by goa v3.13.2, DO NOT EDIT.
//
// Editor HTTP client CLI support package
//
// Command:
// $ goa gen goa.design/model/mdlsvc/design -o mdlsvc/

package client

import (
	"encoding/json"
	"fmt"

	goa "goa.design/goa/v3/pkg"
	editor "goa.design/model/mdlsvc/gen/editor"
)

// BuildUpsertSystemPayload builds the payload for the Editor UpsertSystem
// endpoint from CLI flags.
func BuildUpsertSystemPayload(editorUpsertSystemBody string, editorUpsertSystemGoMod string) (*editor.System, error) {
	var err error
	var body UpsertSystemRequestBody
	{
		err = json.Unmarshal([]byte(editorUpsertSystemBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"Description\": \"System description\",\n      \"Location\": \"External\",\n      \"Name\": \"System\",\n      \"Properties\": {\n         \"key1\": \"value1\",\n         \"key2\": \"value2\"\n      },\n      \"Tags\": [\n         \"Tag1\",\n         \"Tag2\"\n      ],\n      \"URL\": \"https://system.com\"\n   }'")
		}
		if !(body.Location == "Internal" || body.Location == "External") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.Location", body.Location, []any{"Internal", "External"}))
		}
		if err != nil {
			return nil, err
		}
	}
	var goMod string
	{
		goMod = editorUpsertSystemGoMod
		err = goa.MergeErrors(err, goa.ValidatePattern("GoMod", goMod, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &editor.System{
		Name:        body.Name,
		Description: body.Description,
		URL:         body.URL,
		Location:    body.Location,
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	{
		var zero string
		if v.Location == zero {
			v.Location = "Internal"
		}
	}
	if body.Properties != nil {
		v.Properties = make(map[string]string, len(body.Properties))
		for key, val := range body.Properties {
			tk := key
			tv := val
			v.Properties[tk] = tv
		}
	}
	v.GoMod = goMod

	return v, nil
}

// BuildUpsertPersonPayload builds the payload for the Editor UpsertPerson
// endpoint from CLI flags.
func BuildUpsertPersonPayload(editorUpsertPersonBody string, editorUpsertPersonGoMod string) (*editor.Person, error) {
	var err error
	var body UpsertPersonRequestBody
	{
		err = json.Unmarshal([]byte(editorUpsertPersonBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"Description\": \"Person description\",\n      \"Location\": \"Internal\",\n      \"Name\": \"Person\",\n      \"Properties\": {\n         \"key1\": \"value1\",\n         \"key2\": \"value2\"\n      },\n      \"Tags\": [\n         \"Tag1\",\n         \"Tag2\"\n      ],\n      \"URL\": \"https://person.com\"\n   }'")
		}
		if !(body.Location == "Internal" || body.Location == "External") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.Location", body.Location, []any{"Internal", "External"}))
		}
		if err != nil {
			return nil, err
		}
	}
	var goMod string
	{
		goMod = editorUpsertPersonGoMod
		err = goa.MergeErrors(err, goa.ValidatePattern("GoMod", goMod, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &editor.Person{
		Name:        body.Name,
		Description: body.Description,
		URL:         body.URL,
		Location:    body.Location,
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	{
		var zero string
		if v.Location == zero {
			v.Location = "Internal"
		}
	}
	if body.Properties != nil {
		v.Properties = make(map[string]string, len(body.Properties))
		for key, val := range body.Properties {
			tk := key
			tv := val
			v.Properties[tk] = tv
		}
	}
	v.GoMod = goMod

	return v, nil
}

// BuildUpsertContainerPayload builds the payload for the Editor
// UpsertContainer endpoint from CLI flags.
func BuildUpsertContainerPayload(editorUpsertContainerBody string, editorUpsertContainerGoMod string) (*editor.Container, error) {
	var err error
	var body UpsertContainerRequestBody
	{
		err = json.Unmarshal([]byte(editorUpsertContainerBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"Description\": \"Container description\",\n      \"Name\": \"Container\",\n      \"Properties\": {\n         \"key1\": \"value1\",\n         \"key2\": \"value2\"\n      },\n      \"SystemName\": \"My System\",\n      \"Tags\": [\n         \"Tag1\",\n         \"Tag2\"\n      ],\n      \"Technology\": \"Technology\",\n      \"URL\": \"https://container.com\"\n   }'")
		}
	}
	var goMod string
	{
		goMod = editorUpsertContainerGoMod
		err = goa.MergeErrors(err, goa.ValidatePattern("GoMod", goMod, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &editor.Container{
		SystemName:  body.SystemName,
		Name:        body.Name,
		Description: body.Description,
		Technology:  body.Technology,
		URL:         body.URL,
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	if body.Properties != nil {
		v.Properties = make(map[string]string, len(body.Properties))
		for key, val := range body.Properties {
			tk := key
			tv := val
			v.Properties[tk] = tv
		}
	}
	v.GoMod = goMod

	return v, nil
}

// BuildUpsertComponentPayload builds the payload for the Editor
// UpsertComponent endpoint from CLI flags.
func BuildUpsertComponentPayload(editorUpsertComponentBody string, editorUpsertComponentGoMod string) (*editor.Component, error) {
	var err error
	var body UpsertComponentRequestBody
	{
		err = json.Unmarshal([]byte(editorUpsertComponentBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"ContainerName\": \"My Container\",\n      \"Description\": \"Component description\",\n      \"Name\": \"Component\",\n      \"Properties\": {\n         \"key1\": \"value1\",\n         \"key2\": \"value2\"\n      },\n      \"SystemName\": \"My System\",\n      \"Tags\": [\n         \"Tag1\",\n         \"Tag2\"\n      ],\n      \"Technology\": \"Technology\",\n      \"URL\": \"https://component.com\"\n   }'")
		}
	}
	var goMod string
	{
		goMod = editorUpsertComponentGoMod
		err = goa.MergeErrors(err, goa.ValidatePattern("GoMod", goMod, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &editor.Component{
		SystemName:    body.SystemName,
		ContainerName: body.ContainerName,
		Name:          body.Name,
		Description:   body.Description,
		Technology:    body.Technology,
		URL:           body.URL,
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	if body.Properties != nil {
		v.Properties = make(map[string]string, len(body.Properties))
		for key, val := range body.Properties {
			tk := key
			tv := val
			v.Properties[tk] = tv
		}
	}
	v.GoMod = goMod

	return v, nil
}

// BuildUpsertRelationshipPayload builds the payload for the Editor
// UpsertRelationship endpoint from CLI flags.
func BuildUpsertRelationshipPayload(editorUpsertRelationshipBody string, editorUpsertRelationshipGoMod string) (*editor.Relationship, error) {
	var err error
	var body UpsertRelationshipRequestBody
	{
		err = json.Unmarshal([]byte(editorUpsertRelationshipBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"Description\": \"Relationship description\",\n      \"DestinationPath\": \"Software System/Container/Component\",\n      \"InteractionStyle\": \"Synchronous\",\n      \"SourcePath\": \"Software System/Container/Component\",\n      \"Tags\": [\n         \"Tag1\",\n         \"Tag2\"\n      ],\n      \"Technology\": \"Technology\",\n      \"URL\": \"https://relationship.com\"\n   }'")
		}
		if !(body.InteractionStyle == "Synchronous" || body.InteractionStyle == "Asynchronous") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.InteractionStyle", body.InteractionStyle, []any{"Synchronous", "Asynchronous"}))
		}
		if body.URL != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.URL", *body.URL, goa.FormatURI))
		}
		if err != nil {
			return nil, err
		}
	}
	var goMod string
	{
		goMod = editorUpsertRelationshipGoMod
		err = goa.MergeErrors(err, goa.ValidatePattern("GoMod", goMod, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &editor.Relationship{
		SourcePath:       body.SourcePath,
		DestinationPath:  body.DestinationPath,
		Description:      body.Description,
		Technology:       body.Technology,
		InteractionStyle: body.InteractionStyle,
		URL:              body.URL,
	}
	{
		var zero string
		if v.InteractionStyle == zero {
			v.InteractionStyle = "Synchronous"
		}
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	v.GoMod = goMod

	return v, nil
}

// BuildDeleteSystemPayload builds the payload for the Editor DeleteSystem
// endpoint from CLI flags.
func BuildDeleteSystemPayload(editorDeleteSystemName string, editorDeleteSystemGoMod string) (*editor.DeleteSystemPayload, error) {
	var err error
	var name string
	{
		name = editorDeleteSystemName
	}
	var goMod string
	{
		goMod = editorDeleteSystemGoMod
		err = goa.MergeErrors(err, goa.ValidatePattern("GoMod", goMod, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &editor.DeleteSystemPayload{}
	v.Name = name
	v.GoMod = goMod

	return v, nil
}

// BuildDeletePersonPayload builds the payload for the Editor DeletePerson
// endpoint from CLI flags.
func BuildDeletePersonPayload(editorDeletePersonName string, editorDeletePersonGoMod string) (*editor.DeletePersonPayload, error) {
	var err error
	var name string
	{
		name = editorDeletePersonName
	}
	var goMod string
	{
		goMod = editorDeletePersonGoMod
		err = goa.MergeErrors(err, goa.ValidatePattern("GoMod", goMod, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &editor.DeletePersonPayload{}
	v.Name = name
	v.GoMod = goMod

	return v, nil
}

// BuildDeleteContainerPayload builds the payload for the Editor
// DeleteContainer endpoint from CLI flags.
func BuildDeleteContainerPayload(editorDeleteContainerSystemName string, editorDeleteContainerName string, editorDeleteContainerGoMod string) (*editor.DeleteContainerPayload, error) {
	var err error
	var systemName string
	{
		systemName = editorDeleteContainerSystemName
	}
	var name string
	{
		name = editorDeleteContainerName
	}
	var goMod string
	{
		goMod = editorDeleteContainerGoMod
		err = goa.MergeErrors(err, goa.ValidatePattern("GoMod", goMod, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &editor.DeleteContainerPayload{}
	v.SystemName = systemName
	v.Name = name
	v.GoMod = goMod

	return v, nil
}

// BuildDeleteComponentPayload builds the payload for the Editor
// DeleteComponent endpoint from CLI flags.
func BuildDeleteComponentPayload(editorDeleteComponentSystemName string, editorDeleteComponentContainerName string, editorDeleteComponentName string, editorDeleteComponentGoMod string) (*editor.DeleteComponentPayload, error) {
	var err error
	var systemName string
	{
		systemName = editorDeleteComponentSystemName
	}
	var containerName string
	{
		containerName = editorDeleteComponentContainerName
	}
	var name string
	{
		name = editorDeleteComponentName
	}
	var goMod string
	{
		goMod = editorDeleteComponentGoMod
		err = goa.MergeErrors(err, goa.ValidatePattern("GoMod", goMod, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &editor.DeleteComponentPayload{}
	v.SystemName = systemName
	v.ContainerName = containerName
	v.Name = name
	v.GoMod = goMod

	return v, nil
}

// BuildDeleteRelationshipPayload builds the payload for the Editor
// DeleteRelationship endpoint from CLI flags.
func BuildDeleteRelationshipPayload(editorDeleteRelationshipSourcePath string, editorDeleteRelationshipDestinationPath string, editorDeleteRelationshipGoMod string) (*editor.DeleteRelationshipPayload, error) {
	var err error
	var sourcePath string
	{
		sourcePath = editorDeleteRelationshipSourcePath
	}
	var destinationPath string
	{
		destinationPath = editorDeleteRelationshipDestinationPath
	}
	var goMod string
	{
		goMod = editorDeleteRelationshipGoMod
		err = goa.MergeErrors(err, goa.ValidatePattern("GoMod", goMod, "^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}/[a-zA-Z0-9_\\-]+/(/([a-zA-Z0-9_\\-]+))*$"))
		if err != nil {
			return nil, err
		}
	}
	v := &editor.DeleteRelationshipPayload{}
	v.SourcePath = sourcePath
	v.DestinationPath = destinationPath
	v.GoMod = goMod

	return v, nil
}
