// Code generated by goa v3.13.2, DO NOT EDIT.
//
// Module HTTP client encoders and decoders
//
// Command:
// $ goa gen goa.design/model/mdlsvc/design -o mdlsvc/

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"

	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
	module "goa.design/model/mdlsvc/gen/module"
)

// BuildListModulesRequest instantiates a HTTP request object with method and
// path set to call the "Module" service "ListModules" endpoint
func (c *Client) BuildListModulesRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListModulesModulePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Module", "ListModules", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeListModulesResponse returns a decoder for responses returned by the
// Module ListModules endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeListModulesResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListModulesResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Module", "ListModules", err)
			}
			for _, e := range body {
				if e != nil {
					if err2 := ValidateModuleResponse(e); err2 != nil {
						err = goa.MergeErrors(err, err2)
					}
				}
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("Module", "ListModules", err)
			}
			res := NewListModulesModuleOK(body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Module", "ListModules", resp.StatusCode, string(body))
		}
	}
}

// BuildSubscribeRequest instantiates a HTTP request object with method and
// path set to call the "Module" service "Subscribe" endpoint
func (c *Client) BuildSubscribeRequest(ctx context.Context, v any) (*http.Request, error) {
	scheme := c.scheme
	switch c.scheme {
	case "http":
		scheme = "ws"
	case "https":
		scheme = "wss"
	}
	u := &url.URL{Scheme: scheme, Host: c.host, Path: SubscribeModulePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Module", "Subscribe", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeSubscribeRequest returns an encoder for requests sent to the Module
// Subscribe server.
func EncodeSubscribeRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*module.Module)
		if !ok {
			return goahttp.ErrInvalidType("Module", "Subscribe", "*module.Module", v)
		}
		values := req.URL.Query()
		values.Add("mod", p.GoMod)
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeSubscribeResponse returns a decoder for responses returned by the
// Module Subscribe endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeSubscribeResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusSwitchingProtocols:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Module", "Subscribe", err)
			}
			err = goa.MergeErrors(err, goa.ValidateFormat("body", body, goa.FormatJSON))
			if err != nil {
				return nil, goahttp.ErrValidationError("Module", "Subscribe", err)
			}
			res := NewSubscribeModelSwitchingProtocols(body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Module", "Subscribe", resp.StatusCode, string(body))
		}
	}
}

// BuildGetModelRequest instantiates a HTTP request object with method and path
// set to call the "Module" service "GetModel" endpoint
func (c *Client) BuildGetModelRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetModelModulePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Module", "GetModel", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetModelRequest returns an encoder for requests sent to the Module
// GetModel server.
func EncodeGetModelRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*module.Module)
		if !ok {
			return goahttp.ErrInvalidType("Module", "GetModel", "*module.Module", v)
		}
		values := req.URL.Query()
		values.Add("mod", p.GoMod)
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetModelResponse returns a decoder for responses returned by the
// Module GetModel endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeGetModelResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			return nil, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Module", "GetModel", resp.StatusCode, string(body))
		}
	}
}

// BuildCompileRequest instantiates a HTTP request object with method and path
// set to call the "Module" service "Compile" endpoint
func (c *Client) BuildCompileRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		body io.Reader
	)
	rd, ok := v.(*module.CompileRequestData)
	if !ok {
		return nil, goahttp.ErrInvalidType("Module", "Compile", "module.CompileRequestData", v)
	}
	body = rd.Body
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CompileModulePath()}
	req, err := http.NewRequest("POST", u.String(), body)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Module", "Compile", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCompileRequest returns an encoder for requests sent to the Module
// Compile server.
func EncodeCompileRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		data, ok := v.(*module.CompileRequestData)
		if !ok {
			return goahttp.ErrInvalidType("Module", "Compile", "*module.CompileRequestData", v)
		}
		p := data.Payload
		values := req.URL.Query()
		values.Add("mod", p.GoMod)
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeCompileResponse returns a decoder for responses returned by the Module
// Compile endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodeCompileResponse may return the following errors:
//   - "compilation_failed" (type *goa.ServiceError): http.StatusBadRequest
//   - error: internal error
func DecodeCompileResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Module", "Compile", err)
			}
			err = goa.MergeErrors(err, goa.ValidateFormat("body", body, goa.FormatJSON))
			if err != nil {
				return nil, goahttp.ErrValidationError("Module", "Compile", err)
			}
			res := NewCompileModelOK(body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CompileCompilationFailedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Module", "Compile", err)
			}
			err = ValidateCompileCompilationFailedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Module", "Compile", err)
			}
			return nil, NewCompileCompilationFailed(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Module", "Compile", resp.StatusCode, string(body))
		}
	}
}

// // BuildCompileStreamPayload creates a streaming endpoint request payload from
// the method payload and the path to the file to be streamed
func BuildCompileStreamPayload(payload any, fpath string) (*module.CompileRequestData, error) {
	f, err := os.Open(fpath)
	if err != nil {
		return nil, err
	}
	return &module.CompileRequestData{
		Payload: payload.(*module.Module),
		Body:    f,
	}, nil
}

// BuildGetLayoutRequest instantiates a HTTP request object with method and
// path set to call the "Module" service "GetLayout" endpoint
func (c *Client) BuildGetLayoutRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetLayoutModulePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Module", "GetLayout", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetLayoutRequest returns an encoder for requests sent to the Module
// GetLayout server.
func EncodeGetLayoutRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*module.Module)
		if !ok {
			return goahttp.ErrInvalidType("Module", "GetLayout", "*module.Module", v)
		}
		values := req.URL.Query()
		values.Add("mod", p.GoMod)
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetLayoutResponse returns a decoder for responses returned by the
// Module GetLayout endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeGetLayoutResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			return nil, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Module", "GetLayout", resp.StatusCode, string(body))
		}
	}
}

// BuildWriteDiagramRequest instantiates a HTTP request object with method and
// path set to call the "Module" service "WriteDiagram" endpoint
func (c *Client) BuildWriteDiagramRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		body io.Reader
	)
	rd, ok := v.(*module.WriteDiagramRequestData)
	if !ok {
		return nil, goahttp.ErrInvalidType("Module", "WriteDiagram", "module.WriteDiagramRequestData", v)
	}
	body = rd.Body
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: WriteDiagramModulePath()}
	req, err := http.NewRequest("POST", u.String(), body)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Module", "WriteDiagram", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeWriteDiagramRequest returns an encoder for requests sent to the Module
// WriteDiagram server.
func EncodeWriteDiagramRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		data, ok := v.(*module.WriteDiagramRequestData)
		if !ok {
			return goahttp.ErrInvalidType("Module", "WriteDiagram", "*module.WriteDiagramRequestData", v)
		}
		p := data.Payload
		values := req.URL.Query()
		values.Add("mod", p.GoMod)
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeWriteDiagramResponse returns a decoder for responses returned by the
// Module WriteDiagram endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeWriteDiagramResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Module", "WriteDiagram", resp.StatusCode, string(body))
		}
	}
}

// // BuildWriteDiagramStreamPayload creates a streaming endpoint request payload
// from the method payload and the path to the file to be streamed
func BuildWriteDiagramStreamPayload(payload any, fpath string) (*module.WriteDiagramRequestData, error) {
	f, err := os.Open(fpath)
	if err != nil {
		return nil, err
	}
	return &module.WriteDiagramRequestData{
		Payload: payload.(*module.Module),
		Body:    f,
	}, nil
}

// unmarshalModuleResponseToModuleModule builds a value of type *module.Module
// from a value of type *ModuleResponse.
func unmarshalModuleResponseToModuleModule(v *ModuleResponse) *module.Module {
	res := &module.Module{
		GoMod: *v.GoMod,
	}

	return res
}
