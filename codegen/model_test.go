package codegen

import (
	"encoding/json"
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"goa.design/model/mdl"
	model "goa.design/model/pkg"
)

// A test case has a name and a JSON representation of a design.
type testCase struct {
	Name string
	JSON []byte
}

func TestModel(t *testing.T) {
	// Change to testdata directory so that the JSON function can load the
	// test model Go packages.
	require.NoError(t, os.Chdir("testdata"))

	// Iterate through the test models and for each one generate the JSON
	// representation. Then run the model DSL on the JSON and compare the
	// generated code with the original code.
	entries, err := os.ReadDir(".")
	require.NoError(t, err)
	var cases []testCase
	for _, e := range entries {
		if !e.IsDir() {
			continue
		}
		if e.Name() == "." || e.Name() == ".." {
			continue
		}
		js, err := JSON("test/"+e.Name(), false)
		require.NoError(t, err)
		cases = append(cases, testCase{Name: e.Name(), JSON: js})
	}
	for _, c := range cases {
		t.Run(c.Name, func(t *testing.T) {
			var design mdl.Design
			require.NoError(t, json.Unmarshal(c.JSON, &design))

			got, err := Model(&design, "model")
			require.NoError(t, err)

			byts, err := os.ReadFile(filepath.Join(c.Name, "model.go"))
			require.NoError(t, err)
			// Avoid hard-coding version in test files.
			want := "// Code generated by mdl " + model.Version() + ".\n\n" + string(byts)
			assert.Equal(t, want, string(got), "generated code does not match original code, generated JSON is:\n%s", string(c.JSON))
		})
	}
}
